#!markdown

# Unity 脚本 的 C# 基础
## Hello World

#!csharp

System.Console.WriteLine("Hello. My name is Inigo Montoya.");

#!csharp

string requirements, miracleMax;
requirements = miracleMax = "It would take a miracle.";
System.Console.WriteLine(miracleMax);

#!markdown

## 类型

var

#!markdown

## 数组

是引用类型

#!csharp

int[] arr1 = new int[5];
int[] arr2 = new int[]{1, 2, 3};
int[] arr3 = {1, 2, 3, 4, 5};
int[] arr4 = arr3;

arr3[1] = 5;
System.Console.WriteLine(arr4[1]);

int[,] arr5 = new int[2, 3]{{1, 2, 3}, {1, 2, 3}};

#!markdown

## 类型转换

### 隐式转换

#!csharp

byte a = 5;
int b = a;
b

#!markdown

### 显示转换

#!csharp

byte c = (byte) a;
int d = Convert.ToInt32(c);

Console.WriteLine(c);
Console.WriteLine(d);

#!markdown

### 字符串的转换

#!csharp

int e = 123;
string s = e.ToString();
Console.WriteLine(s);
int f = int.Parse(s);
Console.WriteLine(f);

#!markdown

## 装箱与拆箱

值类型与引用类型的装换．

只有值类型才存在装箱和拆箱．

值类型在栈中，引用类型在栈中保存指向堆中数据的指针，装箱时需要将栈中的数据复制到堆中．

装箱是隐式的，拆箱是显式的，因为你需要告诉 C# 你要给拆出来的值赋予什么类型．

#!csharp

int i = 3;
object o = i;  // 装箱
int j = (int) o;  // 拆箱
Console.WriteLine(j);

#!markdown

## 分支和循环

和 C++ 一样．

#!csharp

int[] a = {1, 2, 3};

foreach (int i in a)  // foreach 是只读遍历，这个 i 不能改变
{
    Console.WriteLine(i);
}

#!markdown

### 冒泡排序

#!csharp

int[] a = {3, 2, 1};

for (int i = 0; i < a.Length - 1; i++)  // n - 1 遍
{
    for (int j = 0; j < a.Length - i - 1; j++)  // 最后 i 个已经冒泡到正确的位置了．
    {
        if (a[j] > a[j + 1])
        {
            int temp = a[j];
            a[j] = a[j + 1];
            a[j + 1] = temp;
        }
    }
}

a

#!markdown

### 选择排序

#!csharp

int[] a = {3, 2, 1};

for (int i = 0; i < a.Length - 1; i++)  // n - 1 遍
{
    int min_idx = i;
    for (int j = i + 1; j < a.Length; j++)
    {
        if (a[j] < a[min_idx]) {
            min_idx = j;
        }
    }
    int temp = a[i];
    a[i] = a[min_idx];
    a[min_idx] = temp;
}

a

#!markdown

## 函数与递归

#!csharp

static void fun(string str) 
{
    Console.WriteLine(str);
}

static void fun(int a, int b = 3) 
{
    Console.WriteLine(a);
    Console.WriteLine(b);
}

fun("Hello");
fun(1);
fun(1, 4);

static int add(int a, int b) {
    return a + b;
}

Console.WriteLine(add(1, 5));

#!csharp

static void swap(ref int a, ref int b) // 把值类型按照引用传递
{
    int temp = a;
    a = b;
    b = temp;
}

int a = 1;
int b = 2;

swap(ref a, ref b);

Console.WriteLine(a);
Console.WriteLine(b);

// swap(1, 2); 不能用字面值

#!csharp

static int Test(out string str) // out 参数在方法中一定要被赋值，否则会报错
{
    str = "Hello";
    return 1;
}

string str;
int num = Test(out str);

Console.WriteLine(str);
Console.WriteLine(num);

#!markdown

## 枚举与结构体

枚举和结构体都是值类型

#!csharp

enum Color { Red = 1, Green, Blue };

Console.WriteLine((int) Color.Red);
Console.WriteLine((int) Color.Green);

Color c = Color.Green;
Console.WriteLine((int) c);

#!csharp

object[] person = {"小王", 20, 89};  // 不好用，因为没有类型信息

struct Person
{
    public string name;
    public int age;
    public int height;
}

Person p = new Person();
p.name = "小王";
p.age = 20;
p.height = 89;

#!markdown

## 命名空间

```csharp
namespace 空间名称
{
    // 代码
}

using 空间名称;
```

#!markdown

## 类与对象

#!markdown

### 属性与构造

构造方法：

- 无返回值
- 方法名与类名相同

### 静态与抽象

- 静态成员：类的变量，不是实例的．
- 静态类：只能包含静态成员．
  
  ```csharp
  static class 类名
  {
      // ...
  }
  ```

#!csharp

class Person
{
    // 字段
    private string name;
    private int age;
    private int height;
    public static int population;  // 静态变量

    // 属性
    public string Name
    {
        get { return name; }  // 允许读
        set { name = (value == "" ? "无名氏" : value); }  // 允许写，value 是外界赋的值
    }

    public int Age {get;}  // 只读属性

    // 构造器
    static Person() { population = 0; }  // 静态构造器

    private Person()
    {
        population++;
    }

    public Person(string name, int age): this()
    {
        this.name = name;
        this.age = age;
    }

    public Person(string name, int age, int height) : this(name, age)
    {
        this.height = height;
    }

    // 析构器
    ~Person()
    {
        Console.WriteLine("析构函数被调用");
    }

    // 一般方法：可以使用静态和非静态的成员和方法
    public void Chat()
    {
        Console.WriteLine($"你好，我是{name}");
    }

    // 静态方法：只能用同为静态的成员方法
    public static void writePopulation()
    {
        Console.WriteLine($"当前人口数：{population}");
    }
}

// 实例化一个对象
Person p = new Person("小张", 2, 180);
p.Chat();
Console.WriteLine(p.Name);
p.Name = "";
Console.WriteLine(p.Name);

Console.WriteLine(Person.population);
Person.writePopulation();

#!markdown

### 继承与多态

- public：完全可访问
- private：同一 class 可访问
- protected：同一 class 或派生的子类可访问
- internal：同一程序集可访问
- protected internal：protected 并 internal
- private protected：protected 且 internal

不写的话，默认是 protected ．

```csharp
class 派生类: 基类
{
    
}
```

多态是同一个行为具有多个不同表现形式或形态的能力，在面向对象编程范式中，多态往往表现为“一个接口，多个功能”．

1. 父类变量指向子类
2. 函数重载

#!csharp

class Animal
{
    public string name = "动物";

    public virtual void say()  // 虚方法
    {
        Console.WriteLine("动物的叫声");
    }

    public void eat()  // 不是虚方法
    {
        Console.WriteLine("动物吃东西");
    }

    public virtual void say(string str)  // 虚方法
    {
        Console.WriteLine($"动物说：{str}");
    }
}

class Dog : Animal
{
    public override void say()
    {
        base.say();
        Console.WriteLine(" 汪汪");
    }

    public new void eat()
    {
        Console.WriteLine("狗吃东西");
    }
}

class Cat : Animal
{
    public override void say()
    {
        base.say();
        Console.WriteLine(" 喵喵");
    }
}

Animal a = new Dog();
Animal b = new Cat();

a.say();
b.say();

a.eat();  // 动物吃东西
((Dog) a).eat();  // 狗吃东西

a.say("你好");
