---
origin: PAT（甲级） 2020 年春 7-4
---

# 1171 Replacement Selection (30 分)

When the input is much too large to fit into memory, we have to do **external sorting** instead of internal sorting. One of the key steps in external sorting is to generate sets of sorted records (also called **runs**) with limited internal memory. The simplest method is to read as many records as possible into the memory, and sort them internally, then write the resulting run back to some tape. The size of each run is the same as the capacity of the internal memory.

**Replacement Selection** sorting algorithm was described in 1965 by Donald Knuth. Notice that as soon as the first record is written to an output tape, the memory it used becomes available for another record. Assume that we are sorting in ascending order, if the next record is not smaller than the record we have just output, then it can be included in the run.

For example, suppose that we have a set of input { 81, 94, 11, 96, 12, 99, 35 }, and our memory can sort 3 records only. By the simplest method we will obtain three runs: { 11, 81, 94 }, { 12, 96, 99 } and { 35 }. According to the replacement selection algorithm, we would read and sort the first 3 records { 81, 94, 11 } and output 11 as the smallest one. Then one space is available so 96 is read in and will join the first run since it is larger than 11. Now we have { 81, 94, 96 }. After 81 is out, 12 comes in but it must belong to the next run since it is smaller than 81. Hence we have { 94, 96, 12 } where 12 will stay since it belongs to the next run. When 94 is out and 99 is in, since 99 is larger than 94, it must belong to the **first run**. Eventually we will obtain two runs: the first one contains { 11, 81, 94, 96, 99 } and the second one contains { 12, 35 }.

Your job is to implement this replacement selection algorithm.

## Input Specification

Each input file contains several test cases. The first line gives two positive integers $N (\le 10^5)$ and $M (< N/2)$, which are the total number of records to be sorted, and the capacity of the internal memory. Then N numbers are given in the next line, all in the range of **int**. All the numbers in a line are separated by a space.

## Output Specification

For each test case, print in each line a run (in ascending order) generated by the replacement selection algorithm. All the numbers in a line must be separated by exactly 1 space, and there must be no extra space at the beginning or the end of the line.

## Sample Input

    13 3
    81 94 11 96 12 99 17 35 28 58 41 75 15

## Sample Output

    11 81 94 96 99
    12 17 28 35 41 58 75
    15

## 题解

### 题意

### 思路

这道题相当于是在内存中实现外部排序，用优先队列就行．真正的外部排序算法需要用到败者树．

### 代码

#### 优先队列

#### 败者树

```cpp
#include <iostream>

using namespace std;

int n, m;

struct WorkArea {
    int key = 0, run = 0;

    bool operator<(const WorkArea& x) const {
        if (run != x.run) return run < x.run;
        else return key < x.key;
    }
} wa[100005];

int loser_tree[100005];
int& winner = loser_tree[0];

void update_loser_tree(int pos, int y) {
    if (pos == 0) winner = y;
    else {
        if (wa[loser_tree[pos]] < wa[y]) {
            update_loser_tree(pos / 2, loser_tree[pos]);
            loser_tree[pos] = y;
        }
        else update_loser_tree(pos / 2, y);
    }
}

void print() {
    static int current_run = 1;
    static bool first_in_run = true;

    if (current_run < wa[winner].run) {
        current_run = wa[winner].run;
        cout << "\n";
        first_in_run = true;
    }

    if (first_in_run) {
        first_in_run = false;
    }
    else cout << " ";

    cout << wa[winner].key;
}

int main() {
    cin >> n >> m;

    for (int i = m - 1; i >= 0; --i) {
        cin >> wa[i].key;
        wa[i].run = 1;
        update_loser_tree((m + i) / 2, i);
    }

    for (int i = m; i < n + m; ++i) {
        print();

        int k = 2147483647;
        if (i < n) cin >> k;

        if (i >= n or k < wa[winner].key) {
            wa[winner].run += 1;
        }
        wa[winner].key = k;
        update_loser_tree((m + winner) / 2, winner);
    }
}
```
